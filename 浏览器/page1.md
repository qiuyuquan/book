## 输入 url 浏览器发生了什么
1. dns域名解析
2. 建立tcp连接
3. 发送http请求
4. 服务器处理请求
5. 响应返回结果
6. 关闭tcp连接
7. 浏览器解析html
8. 浏览器布局渲染

### 1. dns域名解析系统
1. 检查浏览器缓存是否有这个域名的解析过IP地址，有就返回
2. 检查操作系统是否有这个域名的Dns解析结果hosts，有就返回
3. 向本地区的域名服务器查询是否有这个域名解析的记录，（本地域名服务器一般都网络运营商提供）有就返回
4. 本地域名服务器向根DNS服务器查询，根域名服务器判断是那个主域名服务器（.com、.cn、.org），返回对应的主域名服务器地址
5. 本地域名服务器向上一步返回主域名服务器请求，主域名服务器根据域名查找对应IP地址，返回IP地址
6. 本地域名服务器缓存这个域名和对应的ip地址，并把解析结果返回用户
7. 用户将结果缓存本地系统缓存中
8. 域名解析完成

### 2. 建立tcp连接（三次握手）
**序列号seq：** 用来标记数据段的顺序，报文段中携带数据的第一个字节的编号。随机
**确认号ack：** 期待收到对方下一个报文段中第一个数据字节的序号（序列号），一般是序列号+1即为确认号
**确认ACK：** 仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效
**标志位SYN** 连接建立时用于同步序号，当SYN=1，ACK=0时，表示是一个连接请求数据报文。若同意连接，则可以是响应文段中SYN=1，ACK=1。

#### 握手过程
1. 主机a向主机b发送tcp请求连接，其中包含主机a的初始序列号seq=x。（报文中同步标志文SYN=1，ACK=0，表示是一个tcp连接请求数据报文；seq表明传输数据时的第一个数据字节序号是x）
2. 主机b收到请求后，会发回连接确认数据包。（其中确认报文段中，标志文SYN=1，ACK=1表示是一个tcp连接响应数据报文；并包含了主机b的初始序列号seq=y，以及主机b对主机a初始序列号的确认号ack=seq + 1=x + 1）
3. 主机a收到主机b的确认报文后，还需做出解释，发送一个序号seq=x+1，确认号为ack=y+1的报文

#### 问题一、 为什么是三次握手
主要有两个目的：**信息对等**和**防止超时**

###### 1. 信息对等确保双方通信是ok的
1. 第一次握手client向server发送SYN数据包，此时只有server知道自己有收报文能力和client发报文能力
2. 第二次握手server响应client的SYN数据包，client就知道了自己有收发报文的能力和server收发报文的能力
3. 第三次握手client应答server的SYN+ACK数据包，server就能确认自己和对方都有收发报文的能力

###### 2. 防止超时
TTL网络报文的生存时间往往超过TCP请求超时时间，如果两次握手就能创建连接，传数据并释放连接后，第一个超时的连接请求才到达server，server会认为clint创建了新的连接请求，然后确认同意创建，但是client的状态不是SYN_SENT，所以会直接丢弃server的确认数据，server一直等待客户端的数据

#### 问题二、为什么需要第三次握手
第三次握手，是为了防止客户端迟迟没有收到服务端返回的确认报文时，就会放弃连接，重新启动一条新的连接请求，但是服务端不知道客户端没收到，所以服务端会收到两个连接请求，白白浪费一条连接开销。

### 6. 关闭tcp连接（四次挥手过程）
1. client发送一个FIN=1，seq=u的数据包，告知server要关闭tcp连接，同时自己进入FIN_WAIT_1状态
2. server收到FIN，知道client要关闭连接，就发送一个ACK=1, seq=w, ack=u+1的确认收到的数据包，同时自己进入CLOSE_WAIT状态。
3. client收到报文后，知道server已经收到了请求信息，就进入FIN_WAIT_2状态，继续等待server的FIN数据包
4. 当server没有数据要发送给client时，应用进程就会通知TCP释放连接，发送一个FIN=1,seq=w,ack=u+1,ACK=1的数据包给client，同时进入LAST_WAIT状态
5. client收到server的ACK确认和FIN关闭确认请求，发送一个ACK确认给server，seq=w，server进入CLOSE状态，完成4次挥手。而clinet需要等待2MSL(最大报文生存时间)确保最后发送给server的确认包收到后，才进行关闭。

#### 问题一、为什么要四次挥手断开连接
TCP连接是双向的，因此每个方向都必须进行单独关闭，当一方完成它的数据发送任务后，就发送一个FIN来向另一方通告要终止这个方向的连接

Client主动关闭的情况下，Server收到Client的FIN报文时，仅仅表示Client没有数据发送给Server了；但Server可能还有数据要发送给Client，所以Server可能并不会立即关闭SOCKET，而是先回复一个ACK报文，告诉Client**“你发的FIN报文我收到了”**。只有等到Server所有的报文都发送完了，才发送FIN报文。也就是说，被动关闭方的ACK和FIN报文多数情况下都是分开发送的，所以需要四次交互。

[TCP连接建立、断开过程详解](https://juejin.im/post/6844903923694698504#heading-9)
[这次一定让你记住 TCP 三次握手、四手挥手！](https://juejin.im/post/6882667709847339016#heading-8)
[TCP建立连接三次握手和释放连接四次握手](https://blog.csdn.net/guyuealian/article/details/52535294)


### 7. 浏览器解析html
