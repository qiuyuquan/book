## 对spa页面的理解，优缺点
spa仅在web初始化时加载对应的html、js、和css，一旦页面记载完成，spa不会因为用户的操作而进行页面的重新加载和跳转，取而代之的理由路由机制实现html内容转换，避免页面的重新加载。

优点：
1. 用户体验号，不需要重新加载整个页面，避免了不必要的跳转和渲染
2. 前后端职责分离，架构清晰

缺点：
1. 初次加载的资源耗时多
2. seo难度大
3. 所有页面的切换需要自己建立堆栈管理

## v-show与v-if有什么区别
v-if是真正的条件渲染，因为它会确保在切换过程中，条件块内的事件监听器和子组件适当的被销毁和重建，如果在初始渲染时条件为假，则什么也不错，直到条件变为真时，才开始渲染。
v-if适用于在运行时很少改变条件，不需要频繁切换条件的场景；

v-show不管初始条件是什么，元素总是会渲染，并且知识简单的css属性切换
v-show适用于需要非常频繁切换条件的场景

## 怎样理解vue的单向数据流
prop传递形成了一个单向下行绑定：父级prop的更新会向下流动到子组件中，但是反过来不行。这样做的目的是防止子组件意外改变父组件的的状态，从而导致数据流难以理解。子组件只能通过事件通知父组件进行数据修改。

## computed和watch的区别，和使用场景
computed: 计算属性，依赖其它的值，有缓存，只有它依赖的属性值发送改变，下一次获取computed的值时才会重新计算computed。
watch: 观察的一种形式，每当监听的数据变化是都会执行操作。

运用场景
computed: 需要数值计算，并且依赖于其他数值时，利用computed缓存特性，避免每次获取值时，都要重新计算。
watch: 数据变化时执行异步或者开销较大的操作时，使用watch，可以限制我们执行该操作的频率。

## 直接给一个数组项赋值，Vue 能检测到变化吗？
[34道Vue面试题系列：Vue中如何检测数组变化？](https://cloud.tencent.com/developer/inventory/2668/article/1607061)

## 组件中data为什么是一个函数
组件是可复用的vue实例，当组件被多个复用时，组件的data数据应该是相互隔离的，所以就需要组件复用一次，data就需要复制一次。而js中对象是一个引用数据类型，如果不用function返回一个新的内存对象，那么每个组件实例后的data都是内存的同一个地址，一个data改变，其他组件的data也会发生改变。主要是实现作用域隔离。

## vue组件通信的几种方式
1. props/$emit
2. ref与$parent、$children
3. eventBus：通过一个空的vue实例作为中央事件总线，用它来触发事件和监听事件，从而实现任何组件间的通信。
4. $attrs与$listeners
5. provide与inject：祖先组件通过provide提供变量，子孙组件通过inject来注入变量
6. vuex

## vuex介绍
vuex是一个专为vue提供的状态管理模式，主要包括了一下几个模块
* state: 定义数据的数据结构，可设置默认的初始状态
* Getter：从store获取数据，有缓存功能
* Mutation：为一个更改store中状态的方法，必须是同步函数
* Action：用于提交action，而不是直接变更状态
* Module：允许将单一的store拆分为多个store，且同时保存在单一的状态树种

## 前端路由的实现原理（hash与history）
路由是根据不同的url来显示不同页面或者内容的功能，最早是由后端提出的，后端路由有一个缺点就是每次路由切换的时候都需要去刷新页面，这样对前端的用户体验来说就不是很好，因此前端路由就此产生。

好处：
1. 用户体验好，不需要每次都从服务器中获取资源
2. 可以在浏览器中输入指定想要访问url地址
3. 实现前后端分离，方便开发

缺点：
1. 对seo不是很友好
2. 初始加载的时候需要加载更多的资源模块，慢一点
3. 在浏览器中前进和后退重新发送请求，没有合理缓存数据

（1）hash模式的实现原理
改变hash值，不会向服务器发出请求，也不会刷新页面，并且hash值每次在变化的时候，都会触发hashChange事件。因此我们可以监听该事件，来知道hash值发生了什么改变。

（2）history模式的实现原理
html5中新添加了两种新的方法
1. window.history.pushState(data, title, url? )：在会话历史记录中添加一条记录。
2. window.history.replaceState(data, title, url? )：把当前的浏览器地址换成replaceState之后的地址，但是浏览器历史长度没有改变。

html5提出了pushState和replaceState，这两个方法可以用来向历史栈中添加数据，同时在提供了onpopstate事件来监听历史栈变化。
需要服务器的支持，服务器接收到所有请求后，都指向同一个html文件，通过history api 监听popstate事件，用pushState和replaceState来实现

[前端路由hash、history原理及简单的实践下](https://www.cnblogs.com/tugenhua0707/p/10859214.html)

## vue中 key 值的作用？
原理：
vue的虚拟dom算法，在更新虚拟节点时，需要从旧的虚拟列表中查找与新虚拟节点相同的节点进行更新，如果这个过程中设置了属性key，过程就会快很多。

作用：
提高列表渲染的效率，高效的更新虚拟DOM

key值的作用主要分为两种：
**在列表渲染时使用key**
当vue用v-for更新已渲染元素列表时，默认用“就地复用”策略。列表数据修改的时候，会根据key值去判断某个值是否修改，如果修改，则重新渲染，否则复用之前的元素，并且确保复用的元素在对应的索引上渲染。

**使用key属性强制替换元素和组件**

[vue 中 key 值有什么作用？](https://cloud.tencent.com/developer/article/1676293)

## vue 响应式原理
https://juejin.im/post/6844903917898186766

## 虚拟 DOM 的优缺点？实现原理
**什么是虚拟dom**
用js模拟一颗dom树，放在浏览器内存中.当你要变更时，虚拟dom使用diff算法进行新旧虚拟dom的比较，将变更放到变更队列中，然后反应到实际的dom树，减少了dom操作。

**虚拟dom的优势**
优点：
1. 保证性能：虚拟dom可以经过diff找出最小差异，然后进行补丁更新，减少了直接操作dom带来的性能损耗
2. 无需手动操作dom：虚拟dom的diff和patch都是在一次更新中自动进行的，无需手动操作
3. 跨平台：虚拟dom本质上是js对象，可以很方便进行跨平台操作。

缺点：
1. 无法进行极致优化：虽然虚拟DOM+合理的优化，可以应对绝大部分应用的性能要求，但在一些性能要求极高的应用中虚拟DOM，无法进行针对型的极致优化。首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerhtml插入慢。

**虚拟dom过程**
1. 用js对象的方式来表示DOM树结构，然后根据这个对象构建出真实DOM树，插入到文档中。
2. 当状态变更时，重新构建一个新的树，然后用新的树和旧的树做对比diff算法，记录两棵树的差异。
3. 最后把所记录的差异应用到构建的真正DOM树上，视图更新。

diff在比较时分为了三个层级
1. Tree Diff（层级比较）对同一个父级下所有子节点比较，判断节点类型是什么，组件就进行component diff；标签或者元素就element diff
2. component diff：组件类型相同，则继续第一步，否则替换整个组件的内从
3. element diff：如果节点时原生标签，则对比标签名来决定替换还是更新属性，然后进去标签后递归第一步。

