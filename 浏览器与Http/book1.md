## 输入 url 浏览器发生了什么
1. dns域名解析
2. 建立tcp连接
3. 发送http请求
4. 服务器处理请求
5. 响应返回结果
6. 关闭tcp连接
7. 浏览器解析html
8. 浏览器布局渲染

### 1. dns域名解析系统
1. 检查浏览器缓存是否有这个域名的解析过IP地址，有就返回
2. 检查操作系统是否有这个域名的Dns解析结果hosts，有就返回
3. 向本地区的域名服务器查询是否有这个域名解析的记录，（本地域名服务器一般都网络运营商提供）有就返回
4. 本地域名服务器向根DNS服务器查询，根域名服务器判断是那个主域名服务器（.com、.cn、.org），返回对应的主域名服务器地址
5. 本地域名服务器向上一步返回主域名服务器请求，主域名服务器根据域名查找对应IP地址，返回IP地址
6. 本地域名服务器缓存这个域名和对应的ip地址，并把解析结果返回用户
7. 用户将结果缓存本地系统缓存中
8. 域名解析完成

### 2. 建立tcp连接（三次握手）
**序列号seq：** 用来标记数据段的顺序，报文段中携带数据的第一个字节的编号。随机  
**确认号ack：** 期待收到对方下一个报文段中第一个数据字节的序号（序列号），一般是序列号+1即为确认号
**确认ACK：** 仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效  
**标志SYN：** 连接建立时用于同步序号，当SYN=1，ACK=0时，表示是一个连接请求数据报文。若同意连接，则可以是响应文段中SYN=1，ACK=1。

#### 握手过程
1. 主机a向主机b发送tcp请求连接，其中包含主机a的初始序列号seq=x。（报文中同步标志SYN=1，ACK=0，表示是一个tcp连接请求数据报文；seq表明传输数据时的第一个数据字节序号是x）
2. 主机b收到请求后，会发回连接确认数据包。（其中确认报文段中，标志文SYN=1，ACK=1表示是一个tcp连接响应数据报文；并包含了主机b的初始序列号seq=y，以及主机b对主机a初始序列号的确认号ack=x + 1）
3. 主机a收到主机b的确认报文后，还需做出解释，发送一个序号seq=x+1，确认号为ack=y+1的报文

#### 问题一、 为什么是三次握手
主要有两个目的：**信息对等**和**防止超时**

###### 1. 信息对等确保双方通信是ok的
1. 第一次握手client向server发送SYN数据包，此时只有server知道自己有收报文能力和client发报文能力
2. 第二次握手server响应client的SYN数据包，client就知道了自己有收发报文的能力和server收发报文的能力
3. 第三次握手client应答server的SYN+ACK数据包，server就能确认自己和对方都有收发报文的能力

###### 2. 防止超时
TTL网络报文的生存时间往往超过TCP请求超时时间，如果两次握手就能创建连接，传数据并释放连接后，第一个超时的连接请求才到达server，server会认为clint创建了新的连接请求，然后确认同意创建，但是client的状态不是SYN_SENT，所以会直接丢弃server的确认数据，server一直等待客户端的数据

#### 问题二、为什么需要第三次握手
第三次握手，是为了防止客户端迟迟没有收到服务端返回的确认报文时，就会放弃连接，重新启动一条新的连接请求，但是服务端不知道客户端没收到，所以服务端会收到两个连接请求，白白浪费一条连接开销。


#### 问题三、为什么是tcp而不是udp，tcp丢包怎么办，如何知道丢包，怎么知道重传成功
TCP三次握手保证可靠性，而UDP就没有了，信息发出后，不验证是否到达，不可靠。  
丢包就重传。  
有seq，是连续的，如果收到的是不连续，说明中间缺了包；或者是超时了还没收到。
因为有seq吧，所以多一个少一个也是知道的

#### 问题四、TCP和UDP的区别
* UDP
  1. 无连接
  2. 面向报文，只是报文的搬运工
  3. 不可靠，没有拥塞控制
  4. 高效，头部开销只有8字节
  5. 支持一对一、一对多、多对多、多对一
  6. 适合直播、视频、语音、会议等实时性要求高的

* TCP
  1. 面向连接：传输前需要先连接
  2. 可靠的传输
  3. 流量控制：发送方不会发送速度过快，超过接收方的处理能力
  4. 拥塞控制：当网络负载过多时能限制发送方的发送速率
  5. 不提供时延保障
  6. 不提供最小带宽保障

### 6. 关闭tcp连接（四次挥手过程）
1. client发送一个FIN=1，seq=u的数据包，告知server要关闭tcp连接，同时自己进入FIN_WAIT_1状态
2. server收到FIN，知道client要关闭连接，就发送一个ACK=1, seq=w, ack=u+1的确认收到的数据包，同时自己进入CLOSE_WAIT状态。
3. client收到报文后，知道server已经收到了请求信息，就进入FIN_WAIT_2状态，继续等待server的FIN数据包
4. 当server没有数据要发送给client时，应用进程就会通知TCP释放连接，发送一个FIN=1,seq=w,ack=u+1,ACK=1的数据包给client，同时进入LAST_WAIT状态
5. client收到server的ACK确认和FIN关闭确认请求，发送一个ACK确认给server，seq=w，server进入CLOSE状态，完成4次挥手。而clinet需要等待2MSL(最大报文生存时间)确保最后发送给server的确认包收到后，才进行关闭。

#### 问题一、为什么要四次挥手断开连接
TCP连接是双向的，因此每个方向都必须进行单独关闭，当一方完成它的数据发送任务后，就发送一个FIN来向另一方通告要终止这个方向的连接

Client主动关闭的情况下，Server收到Client的FIN报文时，仅仅表示Client没有数据发送给Server了；但Server可能还有数据要发送给Client，所以Server可能并不会立即关闭SOCKET，而是先回复一个ACK报文，告诉Client**“你发的FIN报文我收到了”**。只有等到Server所有的报文都发送完了，才发送FIN报文。也就是说，被动关闭方的ACK和FIN报文多数情况下都是分开发送的，所以需要四次交互。

[面试官，不要再问我三次握手和四次挥手](https://zhuanlan.zhihu.com/p/86426969)  
[TCP连接建立、断开过程详解](https://juejin.im/post/6844903923694698504#heading-9)  
[这次一定让你记住 TCP 三次握手、四手挥手！](https://juejin.im/post/6882667709847339016#heading-8)  
[TCP建立连接三次握手和释放连接四次握手](https://blog.csdn.net/guyuealian/article/details/52535294)  


### 7. 浏览器解析html
**原理**
1. 解析：拉取网络或磁盘上读取的html原始字节码，通过设置的charset编码，转换成相字符
2. token化：通过词法分析器，将字符串解析成token，token中标注当前是开始标签、结束标签或者文本标签
3. 生成Nodes并构建对应的树（DOMTree、CssTree）

**过程**
* 构建DOMTree
* 构建CSSTree
* 根据DOMTree和CSSTree生成render tree，DOM树上每一个节点对应着网页里每一个元素，CssTree树上每个节点对应着网页里每个元素的样式，合并生成render tree
* 布局：根据渲染树来布局，弄清楚每个节点在页面中的确切位置和大小，布局完成后，浏览器立即发出“Paint Setup”和“Paint”事件，然后渲染
* 渲染：讲渲染树中的每个节点转换成屏幕上的实际像素

**注意**
1. dom的解析过程分为阻塞性和非阻塞性，一般情况下css资源是不会阻塞dom，但是实际上dom树的构建树是受js的阻塞的，而js又可以去操作css。因此浏览器在script标签时将标签之前全部css请求并完成，然后执行脚本，再到dom的构建完成，执DOMContentloaded。

2. js的资源又分为
  * 外联js：阻塞DOM渲染
  * 外联defer的js：html遇到此标签时，不阻塞DOM解析，浏览器新开一个队列下载此js，待DOM解析完成后执行。由于dom的构建完成是有浏览器派发DOMContentLoaded来决定，而defer的js是在DOM解析完成后，派发DOMContentLoader之前执行，所以也叫成阻塞DOM渲染
  * 外联async的js：不阻塞html的解析过程，但是这里说的不阻塞是指下载过程不阻塞html的解析。如果下载完成了，但DOM还没解析完成，一样会暂停解析html，先执行脚本再解析html。如果DOM解析完成了，js还没下载完成，则不阻塞DOMContentLoaded的派发。

3. css的加载
  * css加载不会阻塞DOM树的解析
  * css加载会阻塞DOM树的渲染
  * css加载会阻塞后面js的执行

**为什么操作DOM慢**
1. 因为DOM属于渲染引擎的东西，而js是属于js引擎的，在操作js改变dom时，实际上是两个线程之前的通信，操作DOM的次数多的话，势必会带来性能上的消耗。
2. 操作DOM会带来重绘与回流的情况，需要浏览器重新的渲染。

**重绘与重排**
当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素，这个过程中，有两种类似的操作

**重排**
当元素的尺寸，结构发送改变时，需要重新渲染页面。
触发重排的操作
1. 页面首次渲染
2. 浏览器窗口大小改变
3. 元素尺寸，位置，内容发送改变
4. 字体大小变化
5. 添加删除dom元素

**重绘**
当元素样式发生改变不影响布局时，浏览器会使用重绘对元素进行升级

**如何和避免触发重绘与重排**
* css
  1. 避免使用table布局
  2. 避免css表达式
  3. 将动画效果应用到position或fixed的元素上
  4. css3硬件加速

* js
  1. 避免频繁操作样式。
  2. 减少dom的增删查改

[“天龙八步”细说浏览器输入URL后发生了什么](https://www.zsite.com/cms/331.html)  
[深入浅出浏览器渲染原理](https://blog.fundebug.com/2019/01/03/understand-browser-rendering/)  
[瀏覽器是如何解析html的？](https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/647774/)  